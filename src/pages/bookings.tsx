import bookingsApiRepo, {
  BookReturnedPayload,
} from "@/app/api/repositories/bookings.api-repo";
import { Booking, BOOKING_STATUS } from "@/app/models/Booking.model";
import { ssr_authenticated } from "@/app/utils/ssr_authenticated";
import { AppContext } from "@/contexts/AppGlobalContextProvider";
import { useMutation, useQuery } from "@tanstack/react-query";
import { Button, Modal, Radio, Table, Tag } from "antd";
import { ColumnsType } from "antd/lib/table";
import { format } from "date-fns";
import { GetServerSideProps, NextPage } from "next";
import Head from "next/head";
import { useRouter } from "next/router";
import { useContext, useEffect, useState } from "react";

interface ReturnBookMutationPayload extends BookReturnedPayload {
  bookingId: string;
}

interface BookingTableType {
  id: string;
  product: string;
  status: "CONSUMING" | "RETURNED";
  borrowed_at: Date;
  rent_price: number;
  returned_at: Date;
  estimated_end_date: Date;
}

interface Props {
  initialBookings: Booking[];
}
const BookingsPage: NextPage<Props> = () => {
  const { currentUserId, currentUserLoading } = useContext(AppContext);
  const router = useRouter();

  useEffect(() => {
    if (!currentUserLoading) if (!currentUserId) router.push("/login");
  }, [currentUserId, currentUserLoading]);

  const [filterMode, setFilterMode] = useState<BOOKING_STATUS | null>(null);
  const [intendedBooking, setIntendedBooking] =
    useState<BookingTableType | null>(null);

  const {
    data: myBookings,
    isFetching,
    refetch,
  } = useQuery(["myBookings", filterMode], async () => {
    const { data } = await bookingsApiRepo.myBookings({
      limit: 100,
      page: 1,
      status: filterMode,
    });
    return data?.data?.contents;
  });

  const { mutate: mutate__returnBooking } = useMutation(
    (variables: ReturnBookMutationPayload) => {
      return bookingsApiRepo.returnBooking(variables.bookingId, {
        need_repair: variables.need_repair,
      });
    },
    {
      onSuccess: () => {
        setIntendedBooking(null);
        refetch();
      },
    }
  );

  const columns: ColumnsType<BookingTableType> = [
    {
      title: "Product",
      dataIndex: "product",
    },
    {
      title: "Status",
      dataIndex: "status",
      render: (status) =>
        status === "CONSUMING" ? (
          <Tag color="magenta">Consuming</Tag>
        ) : (
          <Tag color="green">Returned</Tag>
        ),
    },
    {
      title: "Borrowed at",
      dataIndex: "borrowed_at",
      render: (borrowed_at) =>
        format(new Date(borrowed_at), "dd/MM/yyyy - HH:mm aa"),
    },
    {
      title: "Estimated return date",
      dataIndex: "estimated_end_date",
      render: (value) => format(new Date(value), "dd/MM/yyyy - HH:mm aa"),
    },
    {
      title: "Returned at",
      dataIndex: "returned_at",
      render: (value) =>
        value ? format(new Date(value), "dd/MM/yyyy - HH:mm aa") : "N/A",
    },
    {
      title: "Cost",
      dataIndex: "rent_price",
      render: (rent_price) =>
        rent_price === 0
          ? "Will be calculated during return"
          : `$${rent_price}`,
    },
    {
      title: "Action",
      render: (row) =>
        !row.returned_at && (
          <Button type="primary" onClick={() => setIntendedBooking(row)}>
            Return
          </Button>
        ),
    },
  ];

  const handleReturnBooking = (row: BookingTableType) => {
    mutate__returnBooking({
      bookingId: row.id,
      need_repair: false,
    });
  };

  return (
    <div>
      <Head>
        <title>Rental App | My bookings</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main>
        <h1 className="text-xl font-semibold">My bookings</h1>

        <div className="my-2">
          <Radio.Group onChange={(e) => setFilterMode(e.target.value)}>
            <Radio.Button type="primary" value={null}>
              No Filter
            </Radio.Button>
            <Radio.Button type="primary" value="CONSUMING">
              Currently Using
            </Radio.Button>
            <Radio.Button type="primary" value="RETURNED">
              Returned
            </Radio.Button>
          </Radio.Group>
        </div>

        <Table
          columns={columns}
          pagination={false}
          dataSource={myBookings?.map((booking) => ({
            id: booking._id,
            product: booking.product.name,
            status: booking.status,
            borrowed_at: booking.borrowed_at,
            estimated_end_date: booking.estimated_end_date,
            rent_price: booking.rent_price,
            returned_at: booking.returned_at,
          }))}
          loading={isFetching}
        />
      </main>
      <Modal
        title="Confirm Return"
        open={Boolean(intendedBooking)}
        onCancel={() => setIntendedBooking(null)}
        onOk={() => handleReturnBooking(intendedBooking!)}
        okText="Return"
      >
        <h1 className="text-xl">{intendedBooking?.product}</h1>
        <b>Borrowed at:</b> {intendedBooking?.borrowed_at.toString()} <br />
        <b>Estimated return time:</b>{" "}
        {intendedBooking?.estimated_end_date.toString()}
      </Modal>
      {/* ddd */}
    </div>
  );
};

// export const getServerSideProps: GetServerSideProps = async (context) => {
//   const user = await ssr_authenticated(context);
//   if (!user) return { redirect: { destination: "/login", permanent: false } };
//   return { props: {} };
// };

export default BookingsPage;
